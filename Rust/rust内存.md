### 1. 指针的字节大小为机器的系统位数
    64位系统指针大小为：8字节
    32位系统指针大小为：4字节
### 2. 堆内存快被用完时，程序有一个内存管理器，会负责使用系统调用向操作系统申请成块的（更多）堆内存。该系统调用一次会申请的内存空间会大于当前所需的内存空间，留下一部分内存空间备用，该操作可以避免频繁的内存调用。
    系统调用内核指令：brk  sbrk
    rust二进制文件依赖C标准库或clib，通过malloc函数调用brk、sbrk
### 3. a在栈内存中的大小时，9 = 4 + 1 + 4，内存对齐有助于系统更快读取数据，所以这里会对a的内存大小进行4字节补齐，最终大小是 9 --> 12
```rust
let a: (char, u8, i32) = ('a', 7, 354);
println!("{}", size_of::<(char, u8, i32)>()); //12 = 4 + 1 + 4
println!("{}", size_of::<(char, u8, i64)>()); //16 = 4 + 1 + 8
println!("{}", align_of::<(char, u8, i32)>()); //4 
println!("{}", align_of::<(char, u8, i64)>()); //8 
```
### 4. 数组和切片
```rust
let a: [i32; 3] = [55, 66, 77];
let v: Vec<i32> = vec![55, 66, 77];
let p: &[i32] = &a[..2]; 
let q: &[i32] = &v[..2];
```
    v是一个指向vector的引用（胖指针），占 3 个 `size`，
    第一个size存储指向可变数组堆内存中的起始地址；
    第二个size存储可变数组的容量；
    第三个size存储可变数组当前的长度。

    p是一个指向数组的引用（胖指针），占 2 个 `size`
    q是一个指向slice的引用（胖指针），占 2 个 `size`
    (这里表明了，指针可以同时指向栈内存和堆内存)；
    第一个size存储指向切片的起始地址；
    第二个指针存储切片的长度。

### 5. String
    String类型和动态数组有同样的内存布局，唯一区别是字符串必须是`utf-8`编码。
```rust
let s1: &str = "hello";
// 如果直接通过字符串自面量的方式赋值变量，这个字符串不会在堆上内存上创建，而是会直接存储在二进制文件（编译后的可执行文件）中，生命周期为`'static`，意味着他们在程序运行期间永远不会被释放。
```
    字符串字面量指针长度对应数组。
    字符串指针长度对应可变数组。
```rust
let s = String::from("hello world");
// error: size can not be known at compile time
// 切片 slice 不能对数据直接进行切片，因为该类型切片在编译时没有已知大小。
let p: str = s[1..3];
``` 
### 6. Rust 中的字符是 Unicode 类型，因此每个字符占据 4 个字节内存空间，但是在字符串中不一样，字符串是 UTF-8 编码，也就是字符串中的字符所占的字节数是变化的(1 - 4)。

